
运行时数据区：

- 程序计数器：当前线程的字节码的行号选择器，每一个线程私有的
- Java 虚拟机栈：每一个方法执行，都会push进去一个栈帧，存储局部变量表、操作数栈；
- 局部变量表：在栈帧中存放了编译期可知的数据类型和堆中的数据引用 - 存储在局部变量槽中，即运行前已经完全确定了，运行期间不需要任何修改；比如方法参数信息
- 本地方法栈：虚拟机栈为字节码服务，本地方法栈为 Native 方法服务
- Java堆：存放对象实例的位置；物理上可以不连续、但是逻辑上需要时连续的
- 方法区：存储类型信息、常量、静态变量、JIT编译后的数据
    - Java8之前一般是永久代，因为设计问题，永久代就被纳入堆管理中，并且是存在默认大小的，所以很容易直接内存溢出；但是新的设计中，只要不到系统线程内存限制就不会存在问题
    - 运行时常量池： class文件解析后，会生成一个常量池表
- 直接内存：不受到虚拟机内存的限制，可以直接分配；比如 NIO可以直接使用 native 直接分配直接内存

Java 对象创建过程:

new → 检查常量池中的类的符号引用 → 为对象分配内存 （分配一个全部连续的内存空间 或者 按照空闲列表分配非连续的空间） → 设置对象头: 元数据、哈希码

对象的内存布局：

- 对象头 ： hashcode 、锁状态、GC分代年龄
- 实例数据 ： 存储的真正的有效信息，包括从父类继承的数据
- 对齐填充：对象的起始地址必须是 8 字节的整数倍

对象的访问定位：

栈中存储的 reference → （毕竟一个 reference 无法定义对象是如何定位，如果可以直接定位了，那么必须存储对象的大小等信息才可以） ，这里走到的是一个堆中的特殊区域 - 句柄池 ，这样的好处就是隔离了一层，堆中的对象移动之后，不用修改 reference 信息