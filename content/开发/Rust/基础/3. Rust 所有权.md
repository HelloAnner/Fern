### 所有权

Rust 中，每一个值都有一个生命周期的所有者。当所有者被释放，那么值就会被清除。

```rust
{  
let point = Box::new((0.625, 0.5)); // 分配point
let label = format!("{:?}", point); // 分配label assert_eq!(label, "(0.625, 0.5)");
}
// 两者都被清除
```

如果再复杂一点，那么就是一个所有权树的概念
![[Pasted image 20231113185306.png|500]]

Rust 正是对这个所有权树做了足够好的分析 ，才可以完成实体关系的可追踪性

但是不能一个对象所有权限制太严格了，所以：
- 可以把一个所有者转移到另一个所有者
- 提供基于计数的 Rc 和 Arc ，可以完成出现多个所有者的情况
- 可以 借用 其 引用。 引用是生命期有限的非所有指针

### 转移

Rust 中 ， 所有权是可以转移的 ， 转移后原来的变为未初始化状态。

Python 将指针从s复制到t和u ， 更新列表的引用计数 ， 不复制堆内存
主要是为了方便垃圾收集 - Java类似
```python
s = ['udon', 'ramen', 'soba'] 
t= s  
u= s
```
![[attachments/Pasted image 20231113190124.png|500]]


C++ 直接就是完全的深复制，堆存在三份对象
```c++
using namespace std;
vector<string> s = { "udon", "ramen", "soba" };
vector<string> t = s;
vector<string> u = s;
```
![[attachments/Pasted image 20231113190306.png|500]]


Rust是保留一份堆对象，同时赋值会转移所有权，所以栈上只有一个地址指向堆
![[attachments/Pasted image 20231113190419.png|500]]
**编译器会认为s 还没有初始化**

类似函数参数调用、元祖对象构建都会转移所有权

转移所有权仅仅是复制一下栈的特征值

### Copy 类型 

对于在堆中存储的对象，会涉及到所有权的转移，那么直接就是栈上的Copy类型数据呢 ， 如一个整型数据，就不必要那么麻烦了，直接复制值就行了

Copy类型组合而成的元祖、或者固定大小的数组都是Copy类型

任何在值清除后需要特殊处理的，都不能是Copy 类型

默认情况下 ,struct 和 enum 不是 Copy 类型

但是我们可以显式声明一下 
```rust
#[derive(Copy, Clone)]
struct Label { number: u32 }
```

### Rc & Arc

如何将三个变量指向一份堆内存，类似Python实现的那个效果？

Rc 就可以帮助我们完成 （Arc 仅仅是线程安全的 Rc类型，允许多个线程之间安全共享）

```rust
use std::rc::Rc;

// Rust可以推断所有这些类型，这里写出来是为了清楚  
let s: Rc<String> = Rc::new("shirataki".to_string()); 
let t: Rc<String> = s.clone();  
let u: Rc<String> = s.clone();
```

对于我们上述的所有权规则，是作用在Rc指针本身，即最后的Rc被清除，这个对象就被清理了



<u>上述的所有权转移和引用计数指针都是为了缓和所有权树过于严苛的方式</u>


- [ ] Rust 所有权 复习 (@2023-12-14)