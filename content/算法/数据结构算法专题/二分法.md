lintcode 254 扔鸡蛋

[[../Leetcode/704. 二分查找|704. 二分查找]]

[[../Leetcode/658. 找到 K 个最接近的元素|658. 找到 K 个最接近的元素]]

[414 · 两个整数相除](https://www.lintcode.com/problem/414/)
位操作 + 除法转换为乘减法
两个数的除法转换为求取系数的过程
y = ax +b  ==> y/x = a
a 可以转换为多个2进制幂

---


[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)
直接使用一次 findFirstIndex + FindLastIndex 就可以完成


[240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)
二维矩阵的搜索策略 ， 从最后一行的行首开始搜索 （保证大或者小的行走方向唯一）
如果遇到小于target的元素 ， 向右走一行
如果遇到大于target的元素 ， 向上走一行
如果遇到等于target的元素，向上走一行 + 向右走一行


[69. Sqrt(x)](https://leetcode.com/problems/sqrtx/)
还是二分的变化 , 可以使用区间的模板 ， 对end判断

如果 int 转为  double 的话  ， 如果 x <=1 ，那么 end 就是 1.0
1e-12 可以表示两个浮点数无限接近 , 而不是 start + 1 < end 

[643. Maximum Average Subarray I](https://leetcode.com/problems/maximum-average-subarray-i/)
这里数量是等于K ，如果是大于等于K呢？


[153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)
target 是 nums[-1]
可以直接模拟二分完成， 如果 nums[mid] >= target  -> start = end , 即序号和元素是反了
最后返回一下 区间里面的最小元素 min(nums[start] , nums[end])



[154. Find Minimum in Rotated Sorted Array II](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/)
但是如果存在重复元素
如何消除重复元素 , nums[mid] == nums[end] end = end-1 ，且没有最后一个元素的target
正常的缩小上界




## 参考
[Offer之路-易筋经 第二层 二分查找 - YouTube](https://www.youtube.com/watch?v=vFY1XYEwMBw&t=1552s&ab_channel=Talentland-%E7%AE%97%E6%B3%95%E7%8E%8B%E5%9B%BD)
